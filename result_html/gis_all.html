<!doctype html>
<html>

<head>
	<title>GIS Functions Scaling</title>

	<script src="./charts/Chart.js"></script>
	<script src="./charts/utils.js"></script>

	<style>
		canvas{
			-moz-user-select: none;
			-webkit-user-select: none;
			-ms-user-select: none;
		}
		.chart-container {
			width: 500px;
			margin-left: 40px;
			margin-right: 40px;
			margin-bottom: 40px;
		}
		.container {
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			justify-content: center;
		}
	</style>
</head>

<body>
	<div class="container"></div>
	<script>
		"use strict";
		const all_colors = window.chartColors
		const all_color_names = Object.keys(window.chartColors)

		const NODES = ['0.1.0-ae520101', '0.1.1-600cc1f6', '0.1.1-75619696']
		const STR_DATASETS = ['0.04585,0.04915,0.04825:0.16845,0.17395,0.1797', '0.095,0.10335,0.09784999999999999:0.2583,0.26905,0.25805', '0.5254,0.52825,0.5017:0.70065,0.7009000000000001,0.6825', '0.0811,0.0835,0.0799:0.22875,0.2289,0.21175', '0.19879999999999998,0.2117,0.2057:0.35735,0.38234999999999997,0.3477', '0.8082499999999999,0.8492999999999999,0.8090999999999999:0.9985,1.0444,0.99495', '0.0176,0.01805,0.0175:0.1393,0.1476,0.13025', '0.01245,0.012750000000000001,0.0124:0.1252,0.1413,0.1402', '1.8926500000000002,195.7784,1.87285:2.16535,52.8219,2.15415', '0.0453,0.048049999999999995,0.0471:0.16365,0.16505,0.1684', '0.0489,0.05045,0.04795:0.1874,0.1738,0.1658', '0.0554,5.64225,0.05455:0.176,1.39295,0.17980000000000002', '0.0172,1.6409500000000001,0.01695:0.13015,0.6846,0.12985', '0.09475,9.69985,0.0965:0.12340000000000001,0.34214999999999995,0.11355000000000001', '0.04815,0.05085,0.04865:0.18985000000000002,0.21275,0.21075', '0.0156,0.018250000000000002,0.01725:0.1333,0.154,0.12655', '0.06405,0.06415,0.0627:0.23360000000000003,0.21925,0.2064', '0.0482,4.7715,0.04755:0.18485000000000001,1.2055500000000001,0.1865', '0.0126,0.012799999999999999,0.01255:0.15615,0.16985,0.15165', '0.02485,0.0251,0.024550000000000002:0.1693,0.1656,0.16185', '0.08365,0.09809999999999999,0.0819:0.2163,0.22510000000000002,0.22705', '0.07125000000000001,0.07695,0.06985:0.20625,0.2032,0.19705', '0.08155,0.08435000000000001,0.07585:0.2252,0.23570000000000002,0.21785', '0.0509,0.05405,0.0521:0.1626,0.1864,0.17065', '0.05565,5.6647,0.056400000000000006:0.21345,1.5381999999999998,0.2099', '0.09570000000000001,0.10694999999999999,0.0978:0.2576,0.25945,0.24755', '0.053599999999999995,0.055499999999999994,0.0541:0.18905,0.1769,0.18695', '0.00255,0.18135,0.0039:0.1832,1.1655,0.16870000000000002', '0.07905,0.08399999999999999,0.0793:0.22360000000000002,0.22594999999999998,0.22015', '0.0995,0.10875,0.10145:0.2646,0.26234999999999997,0.2397', '0.01485,0.015300000000000001,0.01495:0.14405,0.1456,0.15245', '0.07675,0.07925,0.07780000000000001:0.2321,0.2434,0.24270000000000003', '0.01745,0.017349999999999997,0.0172:0.18995,0.18330000000000002,0.1824']
		const SET_NAMES = ['python', 'spark']
		const FUNC_NAMES = ['st_issimple', 'st_touches', 'st_unionaggr', 'st_polygonfromenvelope', 'st_intersection', 'st_curvetoline', 'st_geometrytype', 'st_length', 'st_buffer', 'st_geomfromtext', 'st_envelope', 'st_convexhull', 'st_area', 'st_asgeojson', 'st_hausdorffdistance', 'st_npoints', 'st_within', 'st_centroid', 'st_distancesphere', 'st_distance', 'st_simplifypreservetopology', 'st_makevalid', 'st_equals', 'st_geomfromgeojson', 'st_contains', 'st_overlaps', 'st_isvalid', 'st_astext', 'st_precisionreduce', 'st_crosses', 'st_point', 'st_intersects', 'st_envelopeaggr']

		function myAny(iterable, predicate) {
			for (var index = 0; index < iterable.length; index++) {
				if (predicate(iterable[index])) return true;
			}
			return false;
		}

		function myAll(iterable, predicate) {
			for (var index = 0; index < iterable.length; index++) {
				if (!predicate(iterable[index])) return false;
			}
			return true;
		}


		const formatInt = (num, prec = 2, ceil = true) => {
			// formatInt(2345, 2, true)  -> 2400
			// formatInt(2345, 2. false) -> 2300
			// formatInt(2345, 3, true)  -> 3000
			// formatInt(2345, 3, false) -> 2000
			const len = String(num).length;
			if (len < prec) { return num };

			const mult = Math.pow(10, prec);
			return ceil ?
					Math.ceil(num / mult) * mult :
					Math.floor(num / mult) * mult;
		}

		function _checkNaN(x){
			return isNaN(x) && !Array.isArray(x)
		}

		function parse_datasets(STR_DATASETS){
			let result = [];
			for(let i = 0; i < STR_DATASETS.length; ++i){
				let data1 = STR_DATASETS[i];
				let data2 = data1.split(':');
				let ret1 = [];
				for(let j = 0; j < SET_NAMES.length; ++j) {
					let ret2 = [];
					let data3 = data2[j];
					let data4 = data3.split(',');
					for (let k = 0; k < data4.length; ++k) {
						let v = parseFloat(data4[k]);
						if (v == 0){
						    v = NaN
						}
						ret2.push(v);
					}
					if (myAll(ret2, _checkNaN)){
						ret1.push(NaN)
					}else{
						ret1.push(ret2)
					}
				}
				if (myAll(ret1, _checkNaN)){
					result.push(NaN)
				}else{
					result.push(ret1)
				}
			}
			return result;
		}

		var datasets = parse_datasets(STR_DATASETS)

		function get_i_color(index) {
			let color_index = index % all_color_names.length
			let color_name = all_color_names[color_index]
			let color = all_colors[color_name]
			return color
		}

		function createDataSets(index){
			let result = []
			let data_set = datasets[index]
			if (_checkNaN(data_set)){
				return NaN
			}
			for (let index = 0; index < SET_NAMES.length; ++index){
				let _set = {};
				let color = get_i_color(index)
				let _data = data_set[index]
				// alert(isNaN(_data))
				if (_checkNaN(_data)){
					continue
				}
				_set.data = _data
				_set.label = SET_NAMES[index]
				_set.backgroundColor = color
				_set.borderColor = color
				_set.fill = false
				_set.lineTension = 0
				result.push(_set)
			}
			return  result;
		}

		function createConfig(func_name) {
			let title = func_name
			let _gridLines = {
					display: true,
					drawBorder: true,
					drawOnChartArea: true,
					drawTicks: true
				}

			return {
				type: 'line',
				spanGaps: false,
				data: {
					labels: NODES,
					// datasets: _datasets,
				},
				options: {
					responsive: true,
					title: {
						display: true,
						text: title
					},
					scales: {
						xAxes: [{
							gridLines: _gridLines
						}],
						yAxes: [{
							gridLines: _gridLines,
							ticks: {
								suggestedMin: 5,
								suggestedMax: 10,
								callback: function (value, index, values) {
                                   return value + 's';
                                }
							}
						}]
					}
				}
			};
		}

		window.onload = function() {
			let container = document.querySelector('.container');
			let func_cnt = FUNC_NAMES.length
			for (let index = 0; index < func_cnt; index++){
				let div = document.createElement('div');
				div.classList.add('chart-container');

				let canvas = document.createElement('canvas');
				div.appendChild(canvas);
				container.appendChild(div);

				let data_set = createDataSets(index)
				// alert(data_set)
				if (_checkNaN(data_set)){
					continue
				}
				let ctx = canvas.getContext('2d');
				let config = createConfig(FUNC_NAMES[index]);
				config.data.datasets = data_set
				new Chart(ctx, config);
			}
		};
	</script>`
</body>

</html>
